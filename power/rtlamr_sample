#!/usr/bin/env python3

import argparse
import json
import re
import subprocess
from datetime import datetime

import requests


DEFAULT_URL =  'http://127.0.0.1:8080/telegraf'
METER_TIME_REGEX = r'^([^.]+)\.(\d+)([+-].*)$'
METER_TIME_FORMAT = '%Y-%m-%dT%H:%M:%S%z'
# Ignore any consumption spike this number or higher. The units are daWh so
# over a five minute window this is 120 KWh usage.
CONSUMPTION_SPIKE_IGNORE = 10000


def rtlamr(rtl_tcp_server=None, filterid=None):
    rtlamr_cmd = ['rtlamr', '-msgtype', 'idm', '-format', 'json']
    if rtl_tcp_server:
        rtlamr_cmd.extend(['-server', rtl_tcp_server])
    if filterid:
        rtlamr_cmd.extend(['-filterid', filterid])
    rtlamr = subprocess.Popen(rtlamr_cmd, stdout=subprocess.PIPE,
                              stderr=subprocess.PIPE)
    return rtlamr


def send_meter_read(url, timestamp, meter_read, dry_run=False):
    meter_influxdb = 'electric usage=%di %s' % (
        meter_read, timestamp)
    if not dry_run:
        req = requests.post(url, data=meter_influxdb)
    else:
        print("Sending '%s' to %s" % (meter_influxdb, url))


def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument('--filterid', '-I', help="Filter on this meter ID")
    parser.add_argument('--server', '-s', help="rtl_tcp server")
    parser.add_argument('--url', '-u', help="Telegraf URL")
    parser.add_argument('--dry-run', '-n', action='store_true', default=False,
                        help="dry-run mode")
    parser.add_argument('--verbose', '-v', action='store_true', default=False,
                        help="Verbose mode")
    args = parser.parse_args()
    return args


def main():
    args = parse_args()
    url = args.url or DEFAULT_URL

    time_re = re.compile(METER_TIME_REGEX)
    rtlamr_proc = rtlamr(args.server, args.filterid)
    last_consumption = -1
    while True:
        sample_bytes = rtlamr_proc.stdout.readline()
        if not sample_bytes:
            continue
        sample_line = sample_bytes.decode('utf-8')
        try:
            meter_reading = json.loads(sample_line)
        except json.decoder.JSONDecodeError:
            print("Failed to decode: %s" % sample_line)
            continue
        # Send consumption count to URL.
        consumption_count = int(meter_reading['Message']['LastConsumptionCount'])
        if args.verbose:
            print("Received consumption usage of %d" % consumption_count)
        consumption_change = consumption_count - last_consumption
        if consumption_count >= 2**31:
            # Read error from the meter.
            print("Failed to get sensical consumption count.")
            print(meter_reading)
            continue
        elif last_consumption == consumption_count:
            print("No change in consumption, skipping")
            continue
        elif last_consumption > consumption_count:
            print("Consumption count went backwards, skipping")
            continue
        elif last_consumption > 0 and consumption_change > CONSUMPTION_SPIKE_IGNORE:
            print("Large consumption spike detected (%d), skipping" % consumption_change)
            continue
        # "Time":"2019-06-30T21:03:08.177893784-04:00"
        time_match = time_re.match(meter_reading['Time'])
        if not time_match:
            print("Failed to match against time '%s'" % meter_reading['Time'])
            continue
        meter_strtime = time_match.group(1) + time_match.group(3).replace(':', '')
        meter_time = datetime.strptime(meter_strtime, METER_TIME_FORMAT)
        # Force nanoseconds to zero. Including nanoseconds adds false precision
        # to the reading. Already it only updates every 60 seconds at best and
        # often only has new values every five minutes. Skipping nanoseconds
        # allows InfluxDB to possibly compress the values better without nine
        # random digits attached to every reading.
        timestamp = '{}000000000'.format(int(meter_time.timestamp()))
        send_meter_read(url, timestamp, consumption_count, dry_run=args.dry_run)
        last_consumption = consumption_count


if __name__ == '__main__':
    main()
